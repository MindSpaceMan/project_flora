FROM php:8.3-cli-alpine AS sio_test
RUN apk add --no-cache git zip bash

# Setup php extensions
RUN apk add --no-cache postgresql-dev \
    && docker-php-ext-install pdo_pgsql pdo_mysql

ENV COMPOSER_CACHE_DIR=/tmp/composer-cache
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Setup php app user
ARG USER_ID=1000
RUN adduser -u ${USER_ID} -D -H app
USER app

COPY --chown=app . /app
WORKDIR /app

EXPOSE 8337

CMD ["php", "-S", "0.0.0.0:8337", "-t", "public"]

# new
#1-ый проверяющий:
 #Проект:
 # Плюсы:
 #Развернулся без проблем, кандидат добавил PostgreSQL контейнер.
 #Структура кода понятная и логичная.
 #Используются атрибуты
 #Добавлена документация к API.
 #Добавлены фикстуры
 #Рабочий requests.http
 #Enum
 #final class
 #declare(strict_types=1);
 # Используем Brick\Money для точных финансовых расчетов.
 # readonly modifier
 # В репозитории присутствуют закомментированные куски кода, что создает “шум” в кодовой базе. Это небольшая придирка, но лучше такие вещи убирать.
 # //    /**
   #    //     * @return Coupon[] Returns an array of Coupon objects
   #    //     */
   #    //    public function findByExampleField($value): array
   #    //    {
   #    //        return $this->createQueryBuilder('c')
   #    //            ->andWhere('c.exampleField = :val')
   #    //            ->setParameter('val', $value)
   #    //            ->orderBy('c.id', 'ASC')
   #    //            ->setMaxResults(10)
   #    //            ->getQuery()
   #    //            ->getResult()
   #    //        ;
   #    //    }
   #
   #    //    public function findOneBySomeField($value): ?Coupon
   #    //    {
   #    //        return $this->createQueryBuilder('c')
   #    //            ->andWhere('c.exampleField = :val')
   #    //            ->setParameter('val', $value)
   #    //            ->getQuery()
   #    //            ->getOneOrNullResult()
   #    //        ;
   #    //    }
 #Контроллеры:
 #Минусы:
 #Ручной маппинг реквеста:
 #Использование json_decode
 #Отсюда и толстоватый контроллер и повторяющаяся логика:
 #декодирование json в массив
 #маппинг массива в ДТО
 #запуск валидации и проверка результата валидации
 #всего этого можно было избежать с помощью MapRequestPayload
 # Плюсы:
 #Добавил API документацию.
 #Расчёт цены:
 #Хранение и работа с ценой c типом float
 #Это приводит к ошибкам в математических операциях, сравнении и округлении. В финансах важна абсолютная точность, поэтому лучше использовать integer (в минимальных единицах, например, копейках/центах) или специализированные библиотеки/типов для точных вычислений.
 #Если в сервисе расчета цены не определен налог, он просто не учитывается.
 #Однако валидация на налог из реквеста есть значит, такая ситуация не должна происходить. - сделано.
 #Лучше выбрасывать исключение (Exception) вместо игнорирования.
 # Плюсы:
 #Корректный порядок расчёта (купон, затем налог)
 #+/- есть проверка на отрицательную стоимость
 #Но сделано не так как мы ожидаем.
 #В случае фиксированно купона минимальная цена будет 0.
 #В случае процентной скидки нет проверки, но я полагаю, что кандидат ожидает, что во время создания таких купон будет проверка, что значение не больше 100% - сделано.
 #Валидация:
 # В целом корректная. Почти всё прогоняется через ValidatorInterface
 # Проверки существует ли сущности product и coupon выполнены в контроллере.
 #Payment processors:
 # Плюсы:
 #Создал адаптеры
 #Логика адаптеров практически идентична:
 #Кажется, что кандидат сначала адаптировал Paypal, а затем просто скопировал код для Stripe.
 #Для Paypal логика верная:
 #Выполняет приведение типов из float в int
 #Использует try-catch, чтобы вернуть boolean как результат оплаты.
 #В StripePaymentProcessorAdapter точно такая же логика, из-за этого мы передаем в оплату int (а ожидается float) и только с помощью try-catch определяем результат оплаты.
 #Если StripePaymentProcessor::processPayment() вернет false (не прошла оплата) считается успешным выполнением.
 #Использование адаптеров просто с помощью DI.
 #Адаптеры передаются в конструктор контроллера и в зависимости от типа оплаты из реквесте используется нужный. Нарушается принцип open-closed, в таком коде сложно будет поддерживать добавление новых payment сервисов.
 #Тесты:
 # Хорошие тесты на расчет цены.
 # Плохой тест на проведение оплаты. Тестируется замоканый ответ.
 #Общий вывод:
 #Из сильных минусов:
 #Хранение цены в float и работа с таким типов, нет никакой аккуратности в округление, просто используется приведение типов.(ошибся тут про округление, используется математическое округление, но это не спасает. Подробнее написал об этом выше)
 #Косяк с Payment processors.
 #
 # тонкие контроллеры
 # новые атрибуты и механизмы симфони,
 # не скалярные типы, а сущности в DTO - красивое решение, enum.
 # Расширяемость payment - processor https://symfony.com/doc/current/service_container/compiler_passes.html
 # https://knot.gheb.dev/blog/sf-inject-tagged-iterator/
 #
 # на конец
 #


#old
#1-ый проверяющий:
 #Проект:
 # Плюсы:
 #Развернулся без проблем, кандидат добавил PostgreSQL контейнер.
 #Структура кода понятная и логичная.
 #Используются атрибуты
 #Добавлена документация к API.
 #Добавлены фикстуры
 #Рабочий requests.http
 #Минусы:
 #Не используются:
 #Enum
 #final class
 #readonly modifier
 #declare(strict_types=1);
 #В репозитории присутствуют закомментированные куски кода, что создает “шум” в кодовой базе. Это небольшая придирка, но лучше такие вещи убирать.
 #Контроллеры:
 #Минусы:
 #Ручной маппинг реквеста:
 #Использование json_decode
 #Отсюда и толстоватый контроллер и повторяющаяся логика:
 #декодирование json в массив
 #маппинг массива в ДТО
 #запуск валидации и проверка результата валидации
 #всего этого можно было избежать с помощью MapRequestPayload
 # Плюсы:
 #Добавил API документацию.
 #Расчёт цены:
 # Минусы:
 #Хранение и работа с ценой c типом float
 #Это приводит к ошибкам в математических операциях, сравнении и округлении. В финансах важна абсолютная точность, поэтому лучше использовать integer (в минимальных единицах, например, копейках/центах) или специализированные библиотеки/типов для точных вычислений.
 #Если в сервисе расчета цены не определен налог, он просто не учитывается.
 #Однако валидация на налог из реквеста есть значит, такая ситуация не должна происходить.
 #Лучше выбрасывать исключение (Exception) вместо игнорирования.
 # Плюсы:
 #Корректный порядок расчёта (купон, затем налог)
 #+/- есть проверка на отрицательную стоимость
 #Но сделано не так как мы ожидаем.
 #В случае фиксированно купона минимальная цена будет 0.
 #В случае процентной скидки нет проверки, но я полагаю, что кандидат ожидает, что во время создания таких купон будет проверка, что значение не больше 100%
 #Валидация:
 # В целом корректная. Почти всё прогоняется через ValidatorInterface
 # Проверки существует ли сущности product и coupon выполнены в контроллере.
 #Payment processors:
 # Плюсы:
 #Создал адаптеры
 #Минусы:
 #Логика адаптеров практически идентична:
 #Кажется, что кандидат сначала адаптировал Paypal, а затем просто скопировал код для Stripe.
 #Для Paypal логика верная:
 #Выполняет приведение типов из float в int
 #Использует try-catch, чтобы вернуть boolean как результат оплаты.
 #В StripePaymentProcessorAdapter точно такая же логика, из-за этого мы передаем в оплату int (а ожидается float) и только с помощью try-catch определяем результат оплаты.
 #Если StripePaymentProcessor::processPayment() вернет false (не прошла оплата) считается успешным выполнением.
 #Использование адаптеров просто с помощью DI.
 #Адаптеры передаются в конструктор контроллера и в зависимости от типа оплаты из реквесте используется нужный. Нарушается принцип open-closed, в таком коде сложно будет поддерживать добавление новых payment сервисов.
 #Тесты:
 # Хорошие тесты на расчет цены.
 # Плохой тест на проведение оплаты. Тестируется замоканый ответ.
 #Общий вывод:
 #Из сильных минусов:
 #Хранение цены в float и работа с таким типов, нет никакой аккуратности в округление, просто используется приведение типов.(ошибся тут про округление, используется математическое округление, но это не спасает. Подробнее написал об этом выше)
 #Косяк с Payment processors.
 #
 # тонкие контроллеры
 # новые атрибуты и механизмы симфони,
 # не скалярные типы, а сущности в DTO - красивое решение, enum.
 # Расширяемость payment - processor https://symfony.com/doc/current/service_container/compiler_passes.html
 # https://knot.gheb.dev/blog/sf-inject-tagged-iterator/
 #